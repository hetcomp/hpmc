/* Copyright STIFTELSEN SINTEF 2012
 *
 * This file is part of the HPMC Library.
 *
 * Author(s): Christopher Dyken, <christopher.dyken@sintef.no>
 *
 * HPMC is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * HPMC is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * HPMC.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <sstream>
#include <glhpmc/Field.hpp>
#include <glhpmc/Constants.hpp>
#include <glhpmc/Logger.hpp>

namespace glhpmc {

static const std::string package = "HPMC.field";




#if 0

OldField::OldField( HPMCConstants* constants )
    : m_constants( constants )
{
    m_binary = false;
    m_size[0] = 0;
    m_size[1] = 0;
    m_size[2] = 0;
    m_cells[0] = 0;
    m_cells[1] = 0;
    m_cells[2] = 0;
    m_extent[0] = 1.0f;
    m_extent[1] = 1.0f;
    m_extent[2] = 1.0f;

    m_mode = HPMC_VOLUME_LAYOUT_TEXTURE_3D;
    m_shader_source = "";
    m_tex = 0;
    m_tex_field_channel = GL_RED;
    m_tex_gradient_channels = GL_NONE;
}

bool
OldField::configure()
{
    Logger log( m_constants, package + ".configure" );

    if( (m_size[0] < 2) ||
        (m_size[1] < 2) ||
        (m_size[2] < 2) ||
        (16384 < m_size[0]) ||
        (16384 < m_size[1]) ||
        (16384 < m_size[2]) )
    {
        std::stringstream o;
        o << "Insane field size ("
                       << "field.size = [ "
                       << m_size[0] << " x "
                       << m_size[1] << " x "
                       << m_size[2] << " ]";
        log.errorMessage( o.str() );
        return false;
    }
    if( (m_size[0] <= m_cells[0] ) ||
        (m_size[1] <= m_cells[1] ) ||
        (m_size[2] <= m_cells[2] ) )
    {
        std::stringstream o;
        o << "Field is smaller than cells ("
                       << "field.size = [ "
                       << m_size[0] << " x "
                       << m_size[1] << " x "
                       << m_size[2] << " ], "
                       << "field.cells = [ "
                       << m_cells[0] << " x "
                       << m_cells[0] << " x "
                       << m_cells[0] << " ] )";
        log.errorMessage( o.str() );
        return false;
    }
    return true;
}

const std::string
OldField::fetcherSource(bool gradient) const
{
    return "";
    using std::endl;
    std::stringstream src;


    src << "// generated by HPMC.Field.fetcherSource" << endl;
    // -------------------------------------------------------------------------
    if( m_mode == HPMC_VOLUME_LAYOUT_TEXTURE_3D ) {
        std::string field_channel = "r";
        switch( m_tex_field_channel ) {
        case GL_RED:
            field_channel = "r";
            break;
        case GL_ALPHA:
            field_channel = "a";
            break;
        default:
            break;
        }
        src << "uniform sampler3D  HPMC_scalarfield;" << endl;
        src << "float" << endl;
        src << "HPMC_sample( vec3 p )" << endl;
        src << "{" << endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
        if( m_constants->target() < HPMC_TARGET_GL30_GLSL130 ) {
            src << "    return texture3D( HPMC_scalarfield, p )." << field_channel << ";" << endl;
        }
        else {
            src << "    return texture( HPMC_scalarfield, p )." << field_channel << ";" << endl;
        }
        src << "}" << endl;
        if( gradient && hasGradient() ) {
            src << "vec4" << endl;
            src << "HPMC_sampleGrad( vec3 p )" << endl;
            src << "{" << endl;
            src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
            if( m_constants->target() < HPMC_TARGET_GL30_GLSL130 ) {
                src << "    return texture3D( HPMC_scalarfield, p );" << endl;
            }
            else {
                src << "    return texture( HPMC_scalarfield, p );" << endl;
            }
            src << "}" << endl;
        }
    }
    else if( m_mode == HPMC_VOLUME_LAYOUT_CUSTOM ) {
        src << m_shader_source << endl;
        src << "float" << endl;
        src << "HPMC_sample( vec3 p )" << endl;
        src << "{" << endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
        src << "    return HPMC_fetch( p );" << endl;
        src << "}" << endl;
        if( gradient && hasGradient() ) {
            src << "vec4" << endl;
            src << "HPMC_sampleGrad( vec3 p )" << endl;
            src << "{" << endl;
            src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
            src << "    return HPMC_fetchGrad( p );" << endl;
            src << "}" << endl;
        }
    }
    // -------------------------------------------------------------------------
    else {
        Logger log( m_constants, package + ".fetcherSource" );
        log.errorMessage( "Unknown fetch mode" );
        return "";
    }
    return src.str();
}

/** configures a program that uses fetcher source. */
bool
OldField::setupProgram( OldField::Context& context, GLuint program ) const
{
    Logger log( m_constants, package + ".setupProgram" );
    bool retval = true;
    if( m_mode != HPMC_VOLUME_LAYOUT_CUSTOM ) {
        context.m_loc_tex = glGetUniformLocation( program, "HPMC_scalarfield" );
    }
    else {
        context.m_loc_tex = -1;
    }
    return retval;
}

/** binds textures and updates fetcher uniform values. */
bool
OldField::bind( const Context& context, GLuint texture_unit ) const
{
    Logger log( m_constants, package + ".bind" );

    if( m_mode == HPMC_VOLUME_LAYOUT_TEXTURE_3D ) {
        if( m_constants->debugBehaviour() != HPMC_DEBUG_NONE ) {
            std::stringstream o;
            o << "unit=" << texture_unit
              << ", loc=" << context.m_loc_tex
              << ", tex=" << m_tex;
            log.debugMessage( o.str() );
        }

        glUniform1i( context.m_loc_tex, texture_unit );
        glActiveTextureARB( GL_TEXTURE0_ARB + texture_unit );
        glBindTexture( GL_TEXTURE_3D, m_tex );
    }
    return true;
}

#endif

} // of namespace glhpmc
