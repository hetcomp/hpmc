/* -*- mode: C++; tab-width:4; c-basic-offset: 4; indent-tabs-mode:nil -*-
 ***********************************************************************
 *
 *  File: shadergen.cpp
 *
 *  Created: 24. June 2009
 *
 *  Version: $Id: $
 *
 *  Authors: Christopher Dyken <christopher.dyken@sintef.no>
 *
 *  This file is part of the HPMC library.
 *  Copyright (C) 2009 by SINTEF.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  ("GPL") version 2 as published by the Free Software Foundation.
 *  See the file LICENSE.GPL at the root directory of this source
 *  distribution for additional information about the GNU GPL.
 *
 *  For using HPMC with software that can not be combined with the
 *  GNU GPL, please contact SINTEF for aquiring a commercial license
 *  and support.
 *
 *  SINTEF, Pb 124 Blindern, N-0314 Oslo, Norway
 *  http://www.sintef.no
 *********************************************************************/

#include <cstdlib>
#include <cmath>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <string>
#include <hpmc.h>
#include <hpmc_internal.h>

using std::endl;
using std::max;
using std::string;
using std::stringstream;
using std::cerr;

// -----------------------------------------------------------------------------
std::string
HPMCgenerateDefines( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateDefines" << endl;
    //      voxel sizes of scalar function
    src << "#define HPMC_FUNC_X        " << h->m_field.m_size[0] << endl;
    src << "#define HPMC_FUNC_X_F      float(HPMC_FUNC_X)" << endl;
    src << "#define HPMC_FUNC_Y        " << h->m_field.m_size[1] << endl;
    src << "#define HPMC_FUNC_Y_F      float(HPMC_FUNC_Y)" << endl;
    src << "#define HPMC_FUNC_Z        " << h->m_field.m_size[2] << endl;
    src << "#define HPMC_FUNC_Z_F      float(HPMC_FUNC_Z)" << endl;
    //      cell grid dimension
    src << "#define HPMC_CELLS_X       " << h->m_field.m_cells[0] << endl;
    src << "#define HPMC_CELLS_X_F     float(HPMC_CELLS_X)" << endl;
    src << "#define HPMC_CELLS_Y       " << h->m_field.m_cells[1] << endl;
    src << "#define HPMC_CELLS_Y_F     float(HPMC_CELLS_Y)" << endl;
    src << "#define HPMC_CELLS_Z       " << h->m_field.m_cells[2] << endl;
    src << "#define HPMC_CELLS_Z_F     float(HPMC_CELLS_Z)" << endl;
    //      cell grid extent
    src << "#define HPMC_GRID_EXT_X_F  float("<<h->m_field.m_extent[0]<<")"<<endl;
    src << "#define HPMC_GRID_EXT_Y_F  float("<<h->m_field.m_extent[1]<<")"<<endl;
    src << "#define HPMC_GRID_EXT_Z_F  float("<<h->m_field.m_extent[2]<<")"<<endl;
    //      tiling in base layer
    src << "#define HPMC_TILES_X       " << h->m_tiling.m_layout[0] << endl;
    src << "#define HPMC_TILES_X_F     float(HPMC_TILES_X)" << endl;
    src << "#define HPMC_TILES_Y       " << h->m_tiling.m_layout[1] << endl;
    src << "#define HPMC_TILES_Y_F     float(HPMC_TILES_Y)" << endl;
    //      tile size in base layer
    src << "#define HPMC_TILE_SIZE_X   " << h->m_tiling.m_tile_size[0] << endl;
    src << "#define HPMC_TILE_SIZE_X_F float(HPMC_TILE_SIZE_X)" << endl;
    src << "#define HPMC_TILE_SIZE_Y   " << h->m_tiling.m_tile_size[1] << endl;
    src << "#define HPMC_TILE_SIZE_Y_F float(HPMC_TILE_SIZE_Y)" << endl;
    //      histopyramid size
    src << "#define HPMC_HP_SIZE_L2  " << h->m_histopyramid.m_size_l2 << endl;

    return src.str();
}

// -----------------------------------------------------------------------------
std::string
HPMCgenerateBaselevelShader( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateBaselevelShader" << endl;
    src << "uniform sampler1D  HPMC_vertex_count;" << endl;
    if( !h->m_field.m_binary ) {
        src << "uniform float      HPMC_threshold;" << endl;
    }
    src << "void" << endl;
    src << "main()" << endl;
    src << "{" << endl;
    if( h->m_field.m_binary ) {
        src << "    const float HPMC_threshold = 0.5;" << endl;
    }
    //          determine which tile we're in, and thus which slice
    src << "    vec2 stp = vec2( HPMC_TILES_X, HPMC_TILES_Y ) * gl_TexCoord[0].xy;"<< endl;
    src << "    float slice = dot( vec2( 1.0, HPMC_TILES_X ), floor( stp ) );"<<endl;
    //          skip slices that don't contain cells
    src << "    if( slice < float(HPMC_CELLS_Z) ) {"<<endl;
    src << "        vec3 tp = vec3( fract(stp), slice );"<<endl;
    //              scale texcoord from tile parameterization to func parameterization
    src << "        tp.xy *= vec2( 2.0 * HPMC_TILE_SIZE_X_F / HPMC_FUNC_X_F,"   << endl;
    src << "                       2.0 * HPMC_TILE_SIZE_Y_F / HPMC_FUNC_Y_F );" << endl;
    //              cell extent in func parameterization
    src << "        vec2 xr = vec2( (HPMC_CELLS_X_F+0.5) / HPMC_FUNC_X_F,"   << endl;
    src << "                        (HPMC_CELLS_X_F-0.5) / HPMC_FUNC_X_F );" << endl;
    src << "        vec2 yb = vec2( (HPMC_CELLS_Y_F+0.5) / HPMC_FUNC_Y_F,"   << endl;
    src << "                        (HPMC_CELLS_Y_F-0.5) / HPMC_FUNC_Y_F );" << endl;
    //              mask out cells outside specified range
    //              (we process 2x2x1 cells in a fragment)
    src << "        bvec2 xmask = bvec2( tp.x < xr.x,"  << endl;
    src << "                             tp.x < xr.y );"<< endl;
    src << "        bvec2 ymask = bvec2( tp.y < yb.x,"  << endl;
    src << "                             tp.y < yb.y );"<< endl;
    src << "        vec4 mask = vec4( xmask.x && ymask.x,"  << endl;
    src << "                          xmask.y && ymask.x,"  << endl;
    src << "                          xmask.x && ymask.y,"  << endl;
    src << "                          xmask.y && ymask.y );"<< endl;
    //              shift distance between voxels in func parameterization
    src << "        const vec3 delta = vec3( 1.0/HPMC_FUNC_X_F," << endl;
    src << "                                 1.0/HPMC_FUNC_Y_F," << endl;
    src << "                                 1.0 );" << endl;
    //              fetch 3x3x2 neighbourhood from scalar field
    //              and build partial MC codes
    for(int c=0; c<3; c++) {
        src << "        vec3 l"
            << c
            << " = vec3( " << endl;
        for(int i=0; i<6; i++) {
            src << "            (HPMC_sample( tp + delta*vec3( "
                << ((i>>1)-0.5) << ", "
                << (c-0.5) << ", "
                << (float)(i&1) << ") ) < HPMC_threshold ? "
                << ((i&1)==0?" 1.0":"16.0") << " : 0.0 )"
                << ((i&1)==0?" +":(i<5?",":"")) << endl;
        }
        src << "        );" << endl;
    }
    //              build codes for 2x2x1 set of voxels,
    //              store code in fractional part
    src << "        vec4 codes = (1.0/256.0)*vec4(" << endl;
    src << "            l0.x+2.0*l0.y+4.0*l1.x +8.0*l1.y+0.5," << endl;
    src << "            l0.y+2.0*l0.z+4.0*l1.y +8.0*l1.z+0.5," << endl;
    src << "            l1.x+2.0*l1.y+4.0*l2.x +8.0*l2.y+0.5," << endl;
    src << "            l1.y+2.0*l1.z+4.0*l2.y +8.0*l2.z+0.5" << endl;
    src << "        );" << endl;
    //              fetch the triangle count for the 2x2x1 set of voxels
    src << "        vec4 counts = vec4(" << endl;
    src << "            texture1D( HPMC_vertex_count, codes.x ).a," << endl;
    src << "            texture1D( HPMC_vertex_count, codes.y ).a," << endl;
    src << "            texture1D( HPMC_vertex_count, codes.z ).a," << endl;
    src << "            texture1D( HPMC_vertex_count, codes.w ).a" << endl;
    src << "        );" << endl;

    // encode the vertex count in the integer part and the code in the fractional part.
    src << "        gl_FragColor = mask*( counts + codes);" << endl;
    src << "    } " << endl;
    src << "    else {" << endl;
    src << "        gl_FragColor = vec4(0.0, 0.0, 0.4, 0.0);" << endl;
    src << "    }" << endl;
    src << "}" << endl;

    return src.str();
}

// -----------------------------------------------------------------------------
std::string
HPMCgenerateReductionShader( struct HPMCHistoPyramid* h, const std::string& filter  )
{
    stringstream src;

    if( h->m_constants->m_target < HPMC_TARGET_GL30_GLSL130 ) {
        src << "// generated by HPMCgenerateReductionShader with filter=\""<<filter<<"\"" << endl;
        src << "uniform sampler2D  HPMC_histopyramid;" << endl;
        src << "uniform vec2       HPMC_delta;" << endl;
        src << "void" << endl;
        src << "main()" << endl;
        src << "{" << endl;
        src << "    vec4 sums = vec4(" << endl;
        src << "        dot( vec4(1.0), " << filter << "( texture2D( HPMC_histopyramid, gl_TexCoord[0].xy+HPMC_delta.xx ) ) )," << std::endl;
        src << "        dot( vec4(1.0), " << filter << "( texture2D( HPMC_histopyramid, gl_TexCoord[0].xy+HPMC_delta.yx ) ) )," << std::endl;
        src << "        dot( vec4(1.0), " << filter << "( texture2D( HPMC_histopyramid, gl_TexCoord[0].xy+HPMC_delta.xy ) ) )," << std::endl;
        src << "        dot( vec4(1.0), " << filter << "( texture2D( HPMC_histopyramid, gl_TexCoord[0].xy+HPMC_delta.yy ) ) )" << std::endl;

        /*for(int i=0; i<4; i++) {
        src << "        dot( vec4(1.0), "
            << filter
            << "( texture2D( HPMC_histopyramid, gl_TexCoord[0].xy+HPMC_delta."
            << ((i&1)==0?'x':'y')
            << ((i&2)==0?'x':'y')
            << " ) ) )"
            << (i<3?",\n":"\n");
    }*/
        src << "    );" << endl;
        src << "    gl_FragColor = sums;" << endl;
        src << "}" << endl;
    }
    else {
        src << "// generated by HPMCgenerateReductionShader with filter=\""<<filter<<"\"" << endl;
        src << "uniform sampler2D  HPMC_histopyramid;" << endl;
        src << "uniform int        HPMC_src_level;" << endl;
        src << "uniform vec2       HPMC_delta;" << endl;
        src << "void" << endl;
        src << "main()" << endl;
        src << "{" << endl;
        src << "    ivec2 tp = 2*ivec2( gl_FragCoord.xy );" << std::endl;
        src << "    vec4 sums = vec4(" << endl;
        src << "        dot( vec4(1.0), " << filter << "( texelFetch( HPMC_histopyramid, tp + ivec2(0,0), HPMC_src_level ) ) )," << std::endl;
        src << "        dot( vec4(1.0), " << filter << "( texelFetch( HPMC_histopyramid, tp + ivec2(1,0), HPMC_src_level ) ) )," << std::endl;
        src << "        dot( vec4(1.0), " << filter << "( texelFetch( HPMC_histopyramid, tp + ivec2(0,1), HPMC_src_level ) ) )," << std::endl;
        src << "        dot( vec4(1.0), " << filter << "( texelFetch( HPMC_histopyramid, tp + ivec2(1,1), HPMC_src_level ) ) )" << std::endl;
        src << "    );" << endl;
        src << "    gl_FragColor = sums;" << endl;
        src << "}" << endl;
    }

    return src.str();
}

// -----------------------------------------------------------------------------
std::string
HPMCgenerateGPGPUVertexPassThroughShader( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateGPGPUVertexPassThroughShader" << endl;
    src << "void" << endl;
    src << "main()" << endl;
    src << "{" << endl;
    src << "    gl_TexCoord[0] = 0.5*gl_Vertex+vec4(0.5);" << endl;
    src << "    gl_Position    = gl_Vertex;" << endl;
    src << "    gl_FrontColor  = gl_Color;" << endl;
    src << "}" << endl;
    return src.str();
}

// -----------------------------------------------------------------------------
std::string
HPMCgenerateScalarFieldFetch( struct HPMCHistoPyramid* h )
{
    stringstream src;

    src << "// generated by HPMCgenerateScalarFieldFetch" << endl;
    // -------------------------------------------------------------------------
    if( h->m_fetch.m_mode == HPMC_VOLUME_LAYOUT_TEXTURE_3D ) {
        src << "uniform sampler3D  HPMC_scalarfield;" << endl;
        src << "float" << endl;
        src << "HPMC_sample( vec3 p )" << endl;
        src << "{" << endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FUNC_Z));" << endl;
        src << "    return texture3D( HPMC_scalarfield, p ).a;" << endl;
        src << "}" << endl;
        if( h->m_fetch.m_gradient ) {
            src << "vec4" << endl;
            src << "HPMC_sampleGrad( vec3 p )" << endl;
            src << "{" << endl;
            src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FUNC_Z));" << endl;
            src << "    return texture3D( HPMC_scalarfield, p );" << endl;
            src << "}" << endl;
        }
    }
    // -------------------------------------------------------------------------
    else if( h->m_fetch.m_mode == HPMC_VOLUME_LAYOUT_CUSTOM ) {
        src << h->m_fetch.m_shader_source << endl;
        src << "float" << endl;
        src << "HPMC_sample( vec3 p )" << endl;
        src << "{" << endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FUNC_Z));" << endl;
        src << "    return HPMC_fetch( p );" << endl;
        src << "}" << endl;
        if( h->m_fetch.m_gradient ) {
            src << "vec4" << endl;
            src << "HPMC_sampleGrad( vec3 p )" << endl;
            src << "{" << endl;
            src << "    p.z = (p.z+0.5)*(1.0/float(HPMC_FUNC_Z));" << endl;
            src << "    return HPMC_fetchGrad( p );" << endl;
            src << "}" << endl;
        }
    }
    // -------------------------------------------------------------------------
    else {
#ifdef DEBUG
        cerr << "HPMC error: Unknown fetch mode." << endl;
#endif
        return "";
    }
    return src.str();
}

// -----------------------------------------------------------------------------
std::string
HPMCgenerateExtractVertexFunction( struct HPMCHistoPyramid* h )
{
    stringstream src;

    if( h->m_constants->m_target < HPMC_TARGET_GL30_GLSL130 ) {
        src << "// generated by HPMCgenerateExtractShaderFunctions"             << endl;
        src << "uniform sampler2D  HPMC_histopyramid;"                          << endl;
        src << "uniform sampler2D  HPMC_edge_table;"                            << endl;
        src << "uniform float      HPMC_key_offset;"                            << endl;
        src << "uniform float      HPMC_threshold;"                             << endl;
        src << "void"                                                           << endl;
        src << "extractVertex( out vec3 a, out vec3 b, out vec3 p, out vec3 n )"                        << endl;
        src << "{"                                                              << endl;
        //          The key index is determined from offset + x-value of vertex.
        src << "    float key_ix = gl_Vertex.x + HPMC_key_offset;"              << endl;
        //          Start traversal in the center of the top element texel.
        src << "    vec2 texpos = vec2(0.5);"                                   << endl;
        //          Texel shift incremental offsets, one element per interval.
        //          These are updated during traversal.
        src << "    vec4 delta_x = vec4( -0.5,  0.5, -0.5, 0.25 );"             << endl;
        src << "    vec4 delta_y = vec4(  0.0, -0.5,  0.0, 0.25 );"             << endl;
        //          First, traverse the upper levels containing only integers
        src << "    vec4 sums,hist,mask;"                                       << endl;
        src << "    for(int i=HPMC_HP_SIZE_L2; i>0; i--) {"                     << endl;
        //              Fetch sub-pyramid sums for the four sub-pyramids.
        src << "        vec4 sums = texture2DLod( HPMC_histopyramid, texpos, float(i) );" << endl;
        //              Determine accummulative sums, refer to key intervals in paper.
        //              hist.x = sums.x
        //              hist.y = sums.x + sums.y
        //              hist.z = sums.x + sums.y + sums.z
        //              hist.w = sums.x + sums.y + hist.z + sums.w
        src << "        vec4 hist = sums;"                                      << endl;
        src << "        hist.w   += hist.z;"                                    << endl;
        src << "        hist.zw  += hist.yy;"                                   << endl;
        src << "        hist.yzw += hist.xxx;"                                  << endl;
        //              Build a mask for next step.
        //              0      <= key < hist.x  ->  mask = (1,1,1,1)
        //              hist.x <= key < hist.y  ->  mask = (0,1,1,1)
        //              hist.y <= key < hist.z  ->  mask = (0,0,1,1)
        //              hist.z <= key < hist.w  ->  mask = (0,0,0,1)
        src << "        vec4 mask = vec4( lessThan( vec4(key_ix), hist ) );"    << endl;
        //              Combine mask with delta_x and delta_y to shift texcoord
        //              0      <= key < hist.x  ->  tp += ( -0.25, -0.25 )
        //              hist.x <= key < hist.y  ->  tp += (  0.25, -0.25 )
        //              hist.y <= key < hist.z  ->  tp += ( -0.25,  0.25 )
        //              hist.z <= key < hist.w  ->  tp += (  0.25,  0.25 )
        src << "        texpos   += vec2( dot( mask, delta_x ), dot( mask, delta_y ) );" << endl;
        //              Subtract start of interval from key index.
        src << "        key_ix   -= dot( sums.xyz, vec3(1.0)-mask.xyz );"   << endl;
        //              Scale texcoord shifts for next level
        src << "        delta_x  *= 0.5;" << endl;
        src << "        delta_y  *= 0.5;" << endl;
        src << "    }" << endl;
        //          Bottom layer traversal, same logic as the loop above
        src << "    vec4 raw  = texture2DLod( HPMC_histopyramid, texpos, 0.0 );" << endl;
        //          MC codes are stored in the fractional part, floor extracts the vertex count.
        src << "    sums = floor(raw);" << endl;
        src << "    hist = sums;" << endl;
        src << "    hist.w   += hist.z;" << endl;
        src << "    hist.zw  += hist.yy;" << endl;
        src << "    hist.yzw += hist.xxx;" << endl;
        src << "    mask = vec4( lessThan( vec4(key_ix), hist ) );" << endl;
        //          The final traversal step determines which of the four elements in the
        //          baselevel that we want to descend into
        src << "    float nib = dot(vec4(mask), vec4(-1.0,-1.0,-1.0, 3.0));" << endl;
        src << "    texpos   += vec2( dot( mask, delta_x ), dot( mask, delta_y ) );" << endl;
        src << "    key_ix   -= dot( sums.xyz, vec3(1.0)-mask.xyz );" << endl;
        //          Extract the corresponding MC code.
        src << "    float val = fract( dot( raw, vec4(equal(vec4(nib),vec4(0,1,2,3))) ) );" << endl;
        //          The base level is tiled, determine which tile we ended up in.
        src << "    vec2 foo = vec2(HPMC_TILES_X_F,HPMC_TILES_Y_F)*texpos;" << endl;
        //          Scale tp from tile parameterization to scalar field parameterization
        src << "    vec2 tp = vec2( (2.0*HPMC_TILE_SIZE_X_F)/HPMC_FUNC_X_F," << endl;
        src << "                    (2.0*HPMC_TILE_SIZE_Y_F)/HPMC_FUNC_Y_F ) * fract(foo);" << endl;
        src << "    float slice = dot( vec2(1.0,HPMC_TILES_X_F), floor(foo));" << endl;
        //          Now we have found the MC cell, next find which edge that this vertex lies on
        src << "    vec4 edge = texture2D( HPMC_edge_table, vec2((1.0/16.0)*(key_ix+0.5), val ) );" << endl;
        if( h->m_field.m_binary ) {
            src << "n = 2.0*fract(edge.xyz)-vec3(1.0);" << endl;
            src << "edge = floor(edge);" << endl;
        }

        
        src << "    vec3 shift = edge.xyz;" << endl;
        src << "    vec3 axis = vec3( equal(vec3(0.0, 1.0, 2.0), vec3(edge.w)) );" << endl;
        //          Calculate sample positions of the two end-points of the edge.

        src << "    vec3 pa = vec3(tp, slice)" << endl;
        src << "            + vec3(1.0/HPMC_FUNC_X_F, 1.0/HPMC_FUNC_Y_F, 1.0)*shift;" << endl;
        src << "    vec3 pb = pa" << endl;
        src << "            + vec3(1.0/HPMC_FUNC_X_F, 1.0/HPMC_FUNC_Y_F, 1.0)*axis;" << endl;
        src << "    a = vec3(pa.x, pa.y, (pa.z+0.5)*(1.0/float(HPMC_FUNC_Z)) );" << endl;
        src << "    b = vec3(pb.x, pb.y, (pb.z+0.5)*(1.0/float(HPMC_FUNC_Z)) );" << endl;
        if( h->m_field.m_binary ) {
            src << "    p = 0.5*(pa+pb);" << endl;
        }
        else {
            if( !h->m_fetch.m_gradient ) {
                //          If we don't have gradient info, we approximate the gradient using forward
                //          differences. The sample at pb is one of the forward samples at pa, so we
                //          save one texture lookup.
                src << "    float va = HPMC_sample( pa );"                          << endl;
                src << "    vec3 na = vec3( HPMC_sample( pa + vec3( 1.0/HPMC_FUNC_X_F, 0.0, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pa + vec3( 0.0, 1.0/HPMC_FUNC_Y_F, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pa + vec3( 0.0, 0.0, 1.0 ) ) );" << endl;
                src << "    vec3 nb = vec3( HPMC_sample( pb + vec3( 1.0/HPMC_FUNC_X_F, 0.0, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pb + vec3( 0.0, 1.0/HPMC_FUNC_Y_F, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pb + vec3( 0.0, 0.0, 1.0 ) ) );" << endl;
                //          Solve linear equation to approximate point that edge pierces iso-surface.
                src << "    float t = (va-HPMC_threshold)/(va-dot(na,axis));"       << endl;
            }
            else {
                //          If we have gradient info, sample pa and pb.
                src << "    vec4 fa = HPMC_sampleGrad( pa );"                       << endl;
                src << "    vec3 na = fa.xyz;"                                      << endl;
                src << "    float va = fa.w;"                                       << endl;
                src << "    vec4 fb = HPMC_sampleGrad( pb );"                       << endl;
                src << "    vec3 nb = fb.xyz;"                                      << endl;
                src << "    float vb = fb.w;"                                       << endl;
                //          Solve linear equation to approximate point that edge pierces iso-surface.
                src << "    float t = (va-HPMC_threshold)/(va-vb);"                 << endl;
            }
            src << "    p = mix(pa, pb, t );"                                       << endl;
            src << "    n = vec3(HPMC_threshold)-mix(na, nb,t);"                    << endl;
        }
        //          p.xy is in normalized texture coordinates, but z is an integer slice number.
        //          First, remove texel center offset
        src << "    p.xy -= vec2(0.5/HPMC_FUNC_X_F, 0.5/HPMC_FUNC_Y_F );" << endl;
        //          And rescale such that domain fits extent.
        src << "    p *= vec3( HPMC_GRID_EXT_X_F * HPMC_FUNC_X_F/(HPMC_CELLS_X_F-0.0)," << endl;
        src << "               HPMC_GRID_EXT_Y_F * HPMC_FUNC_Y_F/(HPMC_CELLS_Y_F-0.0)," << endl;
        src << "               HPMC_GRID_EXT_Z_F * 1.0/(HPMC_CELLS_Z_F) );" << endl;
        src << "    n *= vec3( HPMC_GRID_EXT_X_F/HPMC_CELLS_X_F,"  << endl;
        src << "               HPMC_GRID_EXT_Y_F/HPMC_CELLS_Y_F,"  << endl;
        src << "               HPMC_GRID_EXT_Z_F/HPMC_CELLS_Z_F );"<< endl;
        src << "}" << endl;
    }
    else {
        src << "// generated by HPMCgenerateExtractShaderFunctions" << endl;
        src << "uniform sampler2D  HPMC_histopyramid;" << endl;
        src << "uniform sampler2D  HPMC_edge_table;" << endl;
        src << "uniform float      HPMC_key_offset;" << endl;
        src << "uniform float      HPMC_threshold;" << endl;
        src << "void" << endl;
        src << "extractVertex( out vec3 a, out vec3 b, out vec3 p, out vec3 n )" << endl;
        src << "{" << endl;
        src << "    float key_ix = gl_VertexID + HPMC_key_offset;"              << endl;
        src << "    ivec2 texpos = ivec2(0,0);"                                 << endl;
        // --- Traverse upper levels of histopyramid ---------------------------
        src << "    for(int i=HPMC_HP_SIZE_L2; i>0; i--) {"                     << endl;
        src << "        vec3 sums = texelFetch( HPMC_histopyramid, texpos, i ).xyz;"<< endl;
        src << "        texpos = 2*texpos;"                                     << endl;
        src << "        if( sums.x <= key_ix ) {"                               << endl;
        src << "            key_ix -= sums.x;"                                  << endl;
        src << "            if( sums.y <= key_ix ) {"                           << endl;
        src << "                key_ix -= sums.y;"                              << endl;
        src << "                if( sums.z <= key_ix ) {"                       << endl;
        src << "                    key_ix -= sums.z;"                          << endl;
        src << "                    texpos += ivec2(1,1);"                      << endl;
        src << "                }"                                              << endl;
        src << "                else {"                                         << endl;
        src << "                    texpos += ivec2(0,1);"                      << endl;
        src << "                }"                                              << endl;
        src << "            }"                                                  << endl;
        src << "            else {"                                             << endl;
        src << "                texpos += ivec2(1,0);"                          << endl;
        src << "            }"                                                  << endl;
        src << "        }"                                                      << endl;
        src << "    }"                                                          << endl;
        // --- Traverse base level of histopyramid -----------------------------
        src << "    vec4 raw = texelFetch( HPMC_histopyramid, texpos, 0 );"     << endl;
        src << "    vec3 sums = floor(raw.xyz);"                                << endl;
        src << "    texpos = 2*texpos;"                                         << endl;
        src << "    float nib;"                                                 << endl;
        src << "    if( sums.x <= key_ix ) {"                                   << endl;
        src << "        key_ix -= sums.x;"                                      << endl;
        src << "        if( sums.y <= key_ix ) {"                               << endl;
        src << "            key_ix -= sums.y;"                                  << endl;
        src << "            if( sums.z <= key_ix ) {"                           << endl;
        src << "                key_ix -= sums.z;"                              << endl;
        src << "                texpos += ivec2(1,1);"                          << endl;
        src << "                nib = raw.w;"                                   << endl;
        src << "            }"                                                  << endl;
        src << "            else {"                                             << endl;
        src << "                texpos += ivec2(0,1);"                          << endl;
        src << "                nib = raw.z;"                                   << endl;
        src << "            }"                                                  << endl;
        src << "        }"                                                      << endl;
        src << "        else {"                                                 << endl;
        src << "            texpos += ivec2(1,0);"                              << endl;
        src << "            nib = raw.y;"                                       << endl;
        src << "        }"                                                      << endl;
        src << "    }"                                                          << endl;
        src << "    else {"                                                     << endl;
        src << "        nib = raw.x;"                                           << endl;
        src << "    }"                                                          << endl;
        src << "    float val = fract(nib);"                                    << endl;
        // --- Determine position ----------------------------------------------
        src << "    vec2 baz = vec2(texpos) + vec2(0.5);"                       << endl;
        src << "    vec2 bar = " << (0.5f/(h->m_histopyramid.m_size)) << "*baz;"<<endl;
        src << "    vec2 foo = vec2(HPMC_TILES_X_F,HPMC_TILES_Y_F)*bar;"        << endl;
        //          Scale tp from tile parameterization to scalar field parameterization
        src << "    vec2 tp = vec2( (2.0*HPMC_TILE_SIZE_X_F)/HPMC_FUNC_X_F," << endl;
        src << "                    (2.0*HPMC_TILE_SIZE_Y_F)/HPMC_FUNC_Y_F ) * fract(foo);" << endl;
        src << "    float slice = dot( vec2(1.0,HPMC_TILES_X_F), floor(foo));" << endl;
        //          Now we have found the MC cell, next find which edge that this vertex lies on
        src << "    vec4 edge = texture2D( HPMC_edge_table, vec2((1.0/16.0)*(key_ix+0.5), val ) );" << endl;

        if( h->m_field.m_binary ) {
            src << "n = 2.0*fract(edge.xyz)-vec3(1.0);" << endl;
            src << "edge = floor(edge);" << endl;
        }
        
        src << "    vec3 shift = edge.xyz;"                                     << endl;
        src << "    vec3 axis = vec3( equal(vec3(0.0, 1.0, 2.0), vec3(edge.w)) );" << endl;
        //          Calculate sample positions of the two end-points of the edge.
        src << "    vec3 pa = vec3(tp, slice)"                                  << endl;
        src << "            + vec3(1.0/HPMC_FUNC_X_F, 1.0/HPMC_FUNC_Y_F, 1.0)*shift;" << endl;
        src << "    vec3 pb = pa"                                               << endl;
        src << "            + vec3(1.0/HPMC_FUNC_X_F, 1.0/HPMC_FUNC_Y_F, 1.0)*axis;" << endl;
        src << "    a = vec3(pa.x, pa.y, (pa.z+0.5)*(1.0/float(HPMC_FUNC_Z)) );" << endl;
        src << "    b = vec3(pb.x, pb.y, (pb.z+0.5)*(1.0/float(HPMC_FUNC_Z)) );" << endl;
        if( h->m_field.m_binary ) {
            src << "    p = 0.5*(pa+pb);" << endl;
        }
        else {
            if( !h->m_fetch.m_gradient ) {
                //          If we don't have gradient info, we approximate the gradient using forward
                //          differences. The sample at pb is one of the forward samples at pa, so we
                //          save one texture lookup.
                src << "    float va = HPMC_sample( pa );"                          << endl;
                src << "    vec3 na = vec3( HPMC_sample( pa + vec3( 1.0/HPMC_FUNC_X_F, 0.0, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pa + vec3( 0.0, 1.0/HPMC_FUNC_Y_F, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pa + vec3( 0.0, 0.0, 1.0 ) ) );" << endl;
                src << "    vec3 nb = vec3( HPMC_sample( pb + vec3( 1.0/HPMC_FUNC_X_F, 0.0, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pb + vec3( 0.0, 1.0/HPMC_FUNC_Y_F, 0.0 ) )," << endl;
                src << "                    HPMC_sample( pb + vec3( 0.0, 0.0, 1.0 ) ) );" << endl;
                //          Solve linear equation to approximate point that edge pierces iso-surface.
                src << "    float t = (va-HPMC_threshold)/(va-dot(na,axis));"       << endl;
            }
            else {
                //          If we have gradient info, sample pa and pb.
                src << "    vec4 fa = HPMC_sampleGrad( pa );"                       << endl;
                src << "    vec3 na = fa.xyz;"                                      << endl;
                src << "    float va = fa.w;"                                       << endl;
                src << "    vec4 fb = HPMC_sampleGrad( pb );"                       << endl;
                src << "    vec3 nb = fb.xyz;"                                      << endl;
                src << "    float vb = fb.w;"                                       << endl;
                //          Solve linear equation to approximate point that edge pierces iso-surface.
                src << "    float t = (va-HPMC_threshold)/(va-vb);"                 << endl;
            }
            src << "    p = mix(pa, pb, t );"                                       << endl;
            src << "    n = vec3(HPMC_threshold)-mix(na, nb,t);"                    << endl;
        }
        
        //          p.xy is in normalized texture coordinates, but z is an integer slice number.
        //          First, remove texel center offset
        src << "    p.xy -= vec2(0.5/HPMC_FUNC_X_F, 0.5/HPMC_FUNC_Y_F );"       << endl;
        //          And rescale such that domain fits extent.
        src << "    p *= vec3( HPMC_GRID_EXT_X_F * HPMC_FUNC_X_F/(HPMC_CELLS_X_F-0.0)," << endl;
        src << "               HPMC_GRID_EXT_Y_F * HPMC_FUNC_Y_F/(HPMC_CELLS_Y_F-0.0)," << endl;
        src << "               HPMC_GRID_EXT_Z_F * 1.0/(HPMC_CELLS_Z_F) );"     << endl;
        src << "    n *= vec3( HPMC_GRID_EXT_X_F/HPMC_CELLS_X_F,"               << endl;
        src << "               HPMC_GRID_EXT_Y_F/HPMC_CELLS_Y_F,"               << endl;
        src << "               HPMC_GRID_EXT_Z_F/HPMC_CELLS_Z_F );"             << endl;
        src << "}"                                                              << endl;

    }
    src << "void"                                                           << endl;
    src << "extractVertex( out vec3 p, out vec3 n )"                        << endl;
    src << "{"                                                              << endl;
    src << "    vec3 a, b;"                                                 << endl;
    src << "    extractVertex( a, b, p, n );"                               << endl;
    src << "}"                                                              << endl;
    return src.str();
}
